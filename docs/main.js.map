{"version":3,"file":"main.js","mappings":";;;;;;;;;AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS,YAAY;AACrB,SAAS,YAAY;AACrB,SAAS,YAAY;AACrB,SAAS,YAAY;AACrB,OAAO,YAAY;AACnB,SAAS,YAAY;AACrB,SAAS,YAAY;AACrB,SAAS,YAAY;AACrB,SAAS,YAAY;AACrB,SAAS,aAAa;AACtB,SAAS,aAAa;AACtB,SAAS,aAAa;AACtB,SAAS,aAAa;AACtB,SAAS,aAAa;AACtB,SAAS,aAAa;AACtB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB,SAAS,aAAa;AACtB,IAAI,KAAK,aAAa;AACtB,SAAS,aAAa;AACtB,SAAS,aAAa;AACtB,SAAS,aAAa;AACtB,SAAS,aAAa;AACtB,SAAS,YAAY;AACrB,OAAO,YAAY;AACnB,OAAO,YAAY;AACnB,OAAO,YAAY;AACnB,OAAO,YAAY;AACnB,OAAO,YAAY;AACnB,OAAO,YAAY;AACnB,OAAO,YAAY;AACnB,OAAO,YAAY;AACnB,OAAO,YAAY;AACnB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB,SAAS,aAAa;AACtB,OAAO,YAAY;AACnB,OAAO,YAAY;AACnB,OAAO,YAAY;AACnB,OAAO,YAAY;AACnB,OAAO,YAAY;AACnB,OAAO,YAAY;AACnB,OAAO,YAAY;AACnB,OAAO,YAAY;AACnB,OAAO,YAAY;AACnB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACpGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,kBAAkB;;AAEvC;AACA;AACA,qBAAqB,iBAAiB;AACtC,qBAAqB,gBAAgB;AACrC,MAAM;AACN,qBAAqB,iBAAiB;AACtC,qBAAqB,gBAAgB;AACrC,MAAM;AACN;AACA,qBAAqB,gBAAgB;AACrC,qBAAqB,gBAAgB;AACrC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;ACnGA,MAAM,oCAAoC,EAAE,mBAAO,CAAC,+BAAW;;AAE/D;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC9BA,8BAA8B,mBAAO,CAAC,mFAAqC;AAC3E,uCAAuC,mBAAO,CAAC,uGAA+C;AAC9F,6BAA6B,mBAAO,CAAC,iFAAoC;;AAEzE,4BAA4B,mBAAO,CAAC,6EAAkC;AACtE,+BAA+B,mBAAO,CAAC,qFAAsC;;AAE7E,MAAM,sBAAsB,EAAE,mBAAO,CAAC,6BAAU;AAChD,MAAM,cAAc,EAAE,mBAAO,CAAC,iCAAY;AAC1C,MAAM,UAAU,EAAE,mBAAO,CAAC,iCAAY;AACtC,MAAM,UAAU,EAAE,mBAAO,CAAC,2BAAS;;AAEnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gCAAgC;AAChD;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,gBAAgB,gCAAgC;AAChD;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB;AACnB,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,eAAe;AACnC,sBAAsB,cAAc;AACpC;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,wBAAwB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC3MA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,6BAAU;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,IAAI,mBAAmB,IAAI,IAAI,mBAAmB;;AAEpF;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,WAAW;AACtD;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACpEA,MAAM,sBAAsB,EAAE,mBAAO,CAAC,8BAAW;;AAEjD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACZA,cAAc,mBAAO,CAAC,gCAAY;;AAElC,MAAM,sBAAsB,EAAE,mBAAO,CAAC,8BAAW;;AAEjD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,eAAe;AACjC;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC/DA,mBAAmB,mBAAO,CAAC,oEAA0B;AACrD,MAAM,OAAO,EAAE,mBAAO,CAAC,oDAAkB;AACzC,MAAM,qBAAqB,EAAE,mBAAO,CAAC,4BAAU;;AAE/C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B,4BAA4B;AACvD,8BAA8B,4BAA4B;AAC1D,mBAAmB;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACtOA,qBAAqB,mBAAO,CAAC,wEAA4B;;AAEzD,MAAM,UAAU,EAAE,mBAAO,CAAC,4BAAU;;AAEpC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACpCA,qBAAqB,mBAAO,CAAC,wEAA4B;;AAEzD,MAAM,UAAU,EAAE,mBAAO,CAAC,4BAAU;;AAEpC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA,mBAAmB;AACnB;AACA,YAAY,sBAAsB;AAClC,YAAY,sBAAsB;AAClC,YAAY,sBAAsB;AAClC,YAAY;AACZ;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC7BA,MAAM,UAAU,EAAE,mBAAO,CAAC,4BAAU;;AAEpC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;AChHA,mBAAmB,mBAAO,CAAC,oEAA0B;AACrD,MAAM,OAAO,EAAE,mBAAO,CAAC,oDAAkB;;AAEzC,MAAM,UAAU,EAAE,mBAAO,CAAC,4BAAU;;AAEpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,0BAA0B,2BAA2B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA,2BAA2B,4BAA4B;AACvD,8BAA8B,4BAA4B;AAC1D,mBAAmB;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACzLA,mBAAmB,mBAAO,CAAC,oEAA0B;;AAErD,MAAM,UAAU,EAAE,mBAAO,CAAC,4BAAU;;AAEpC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB;AACrB;AACA,uBAAuB,iBAAiB,SAAS,WAAW;AAC5D;;AAEA;AACA;AACA,iBAAiB;AACjB,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACnGA,MAAM,UAAU,EAAE,mBAAO,CAAC,2BAAS;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,8BAA8B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,+BAAW;;AAEvB;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,6BAAU;;AAEtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,gBAAgB,KAAK,iBAAiB;AAChF;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,iBAAiB;AACrC,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACnGA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd,MAAM;AACN,cAAc;AACd,MAAM;AACN,cAAc;AACd,MAAM;AACN,cAAc;AACd,MAAM;AACN,cAAc;AACd,MAAM;AACN,cAAc;AACd,MAAM;AACN,cAAc;AACd,MAAM;AACN,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,oBAAoB;AACxC,sBAAsB,mBAAmB;AACzC,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,YAAY;AAC9B;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,eAAe;AACjC,oBAAoB,cAAc;AAClC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC1HA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;UCfA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;;;ACtBA,aAAa,mBAAO,CAAC,6BAAU;AAC/B,eAAe,mBAAO,CAAC,iCAAY;AACnC,YAAY,mBAAO,CAAC,2BAAS;AAC7B,MAAM,SAAS,EAAE,mBAAO,CAAC,iCAAY;;AAErC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,6BAAU;;AAEtB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO,gBAAgB;AACvB,OAAO,eAAe;AACtB,OAAO,eAAe;AACtB,OAAO,eAAe;AACtB,OAAO,cAAc;AACrB,OAAO,cAAc;AACrB,OAAO,eAAe;AACtB,SAAS,cAAc;AACvB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mDAAmD,wCAAwC;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC,uBAAuB;AACzD;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS,SAAS;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,aAAa;AAC5D,YAAY;AACZ,gDAAgD,aAAa;AAC7D;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,kCAAkC;AAC/D;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,cAAc;AACzD;AACA,gBAAgB;AAChB,2CAA2C,cAAc;AACzD;AACA;AACA,4CAA4C,aAAa;AACzD;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,aAAa,GAAG,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC,sBAAsB,cAAc;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2BAA2B,kCAAkC;AAC7D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,eAAe;AACnC,sBAAsB,cAAc;AACpC;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,eAAe;AACnC,sBAAsB,cAAc;AACpC;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,WAAW;AAC5C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,qDAAqD,cAAc;;AAEnE;AACA;AACA;AACA;AACA,eAAe,kCAAkC,EAAE,8BAA8B,EAAE,sCAAsC,EAAE,cAAc;AACzI;AACA;AACA;AACA;AACA;AACA,yBAAyB,oBAAoB,WAAW,oBAAoB,KAAK,WAAW;AAC5F;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,QAAQ;AACR,0DAA0D,2BAA2B,KAAK,cAAc;AACxG;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA","sources":["webpack:///./charmap.js","webpack:///./entities.js","webpack:///./layout.js","webpack:///./level.js","webpack:///./logger.js","webpack:///./mapgen/abstract-dungeon-feature.js","webpack:///./mapgen/abstract-map-generator.js","webpack:///./mapgen/binary-space-partition-map-generator.js","webpack:///./mapgen/eroded-room-dungeon-feature.js","webpack:///./mapgen/erosion-dungeon-feature.js","webpack:///./mapgen/mapgen-commons.js","webpack:///./mapgen/random-rooms-map-generator.js","webpack:///./mapgen/random-walk-map-generator.js","webpack:///./monsters.js","webpack:///./renderer.js","webpack:///./tilemap.js","webpack:///./utils.js","webpack:///webpack/bootstrap","webpack:///./index.js"],"sourcesContent":["var charWidthPixels = 9\nvar charHeightPixels = 14\n\n// Map char to location (row, column) in image\nvar charOffsetX = 4\nvar charOffsetY = 4\nvar charMap = {\n  ' ': { i: 0, j: 0 },\n  '!': { i: 1, j: 1 },\n  '\"': { i: 1, j: 2 },\n  '#': { i: 1, j: 3 }, // 2nd row, 4th column\n  $: { i: 1, j: 4 },\n  '%': { i: 1, j: 5 },\n  '&': { i: 1, j: 6 },\n  '(': { i: 1, j: 8 },\n  ')': { i: 1, j: 9 },\n  '*': { i: 1, j: 10 },\n  '+': { i: 1, j: 11 },\n  ',': { i: 1, j: 12 },\n  '-': { i: 1, j: 13 },\n  '.': { i: 1, j: 14 },\n  '/': { i: 1, j: 15 },\n  0: { i: 1, j: 16 },\n  1: { i: 1, j: 17 },\n  2: { i: 1, j: 18 },\n  3: { i: 1, j: 19 },\n  4: { i: 1, j: 20 },\n  5: { i: 1, j: 21 },\n  6: { i: 1, j: 22 },\n  7: { i: 1, j: 23 },\n  8: { i: 1, j: 24 },\n  9: { i: 1, j: 25 },\n  ':': { i: 1, j: 26 },\n  ';': { i: 1, j: 27 },\n  '<': { i: 1, j: 28 },\n  '=': { i: 1, j: 29 },\n  '>': { i: 1, j: 30 },\n  '?': { i: 1, j: 31 },\n  '@': { i: 2, j: 0 },\n  A: { i: 2, j: 1 },\n  B: { i: 2, j: 2 },\n  C: { i: 2, j: 3 },\n  D: { i: 2, j: 4 },\n  E: { i: 2, j: 5 },\n  F: { i: 2, j: 6 },\n  G: { i: 2, j: 7 },\n  H: { i: 2, j: 8 },\n  I: { i: 2, j: 9 },\n  J: { i: 2, j: 10 },\n  K: { i: 2, j: 11 },\n  L: { i: 2, j: 12 },\n  M: { i: 2, j: 13 },\n  N: { i: 2, j: 14 },\n  O: { i: 2, j: 15 },\n  P: { i: 2, j: 16 },\n  Q: { i: 2, j: 17 },\n  R: { i: 2, j: 18 },\n  S: { i: 2, j: 19 },\n  T: { i: 2, j: 20 },\n  U: { i: 2, j: 21 },\n  V: { i: 2, j: 22 },\n  W: { i: 2, j: 23 },\n  X: { i: 2, j: 24 },\n  Y: { i: 2, j: 25 },\n  Z: { i: 2, j: 26 },\n  '_': { i: 2, j: 31 },\n  a: { i: 3, j: 1 },\n  b: { i: 3, j: 2 },\n  c: { i: 3, j: 3 },\n  d: { i: 3, j: 4 },\n  e: { i: 3, j: 5 },\n  f: { i: 3, j: 6 },\n  g: { i: 3, j: 7 },\n  h: { i: 3, j: 8 },\n  i: { i: 3, j: 9 },\n  j: { i: 3, j: 10 },\n  k: { i: 3, j: 11 },\n  l: { i: 3, j: 12 },\n  m: { i: 3, j: 13 },\n  n: { i: 3, j: 14 },\n  o: { i: 3, j: 15 },\n  p: { i: 3, j: 16 },\n  q: { i: 3, j: 17 },\n  r: { i: 3, j: 18 },\n  s: { i: 3, j: 19 },\n  t: { i: 3, j: 20 },\n  u: { i: 3, j: 21 },\n  v: { i: 3, j: 22 },\n  w: { i: 3, j: 23 },\n  x: { i: 3, j: 24 },\n  y: { i: 3, j: 25 },\n  z: { i: 3, j: 26 },\n}\n\nmodule.exports = {\n  charWidthPixels,\n  charHeightPixels,\n  charOffsetX,\n  charOffsetY,\n  charMap\n}\n","function LivingEntity(char, color) {\n  this.char = char\n  this.color = color\n  this.x = 0\n  this.y = 0\n\n  this.hp = 0\n  this.hitChance = 0\n  this.hitDamage = 0\n\n  this.setPosition = function setPosition(position) {\n    this.x = position.x\n    this.y = position.y\n  }\n\n  this.isAdjacentTo = function isAdjacentTo(that) {\n    return Math.max(Math.abs(this.x - that.x), Math.abs(this.y - that.y)) == 1\n  }\n\n  this.attack = function attack(that) {\n    if (Math.random() < this.hitChance) {\n      that.hp -= this.hitDamage\n      return true\n    } else {\n      return false\n    }\n  }\n\n  this.getApproachVectorsTo = function getApproachVectorsTo(that) {\n    var dispX = that.x - this.x\n    var dispY = that.y - this.y\n    var dx0 = dispX != 0 ? (dispX < 0 ? -1 : 1) : 0\n    var dy0 = dispY != 0 ? (dispY < 0 ? -1 : 1) : 0\n\n    var vectors = [{ dx: dx0, dy: dy0 }]\n\n    // If preferred direction along cardinal axis try also both diagonals around it\n    if (dx0 == 0) {\n      vectors.push({ dx: -1, dy: dy0 })\n      vectors.push({ dx: 1, dy: dy0 })\n    } else if (dy0 == 0) {\n      vectors.push({ dx: dx0, dy: -1 })\n      vectors.push({ dx: dx0, dy: 1 })\n    } else {\n      // Preferred direction is diagonal: try also both cardinal directions around it\n      vectors.push({ dx: 0, dy: dy0 })\n      vectors.push({ dx: dx0, dy: 0 })\n    }\n\n    return vectors\n  }\n}\n\nfunction Monster(char, color) {\n  LivingEntity.call(this, char, color)\n\n  this.seen = false\n  this.aggressive = false\n  this.aggravationChance = 0.2\n  this.pointValue = null\n\n  this.rollAggravation = function rollAggravation() {\n    if (this.seen && !this.aggressive && Math.random() < this.aggravationChance) {\n      console.log('monster becomes agressive')\n      this.aggressive = true\n    }\n  }\n}\nMonster.fromSpawner = function(spawner) {\n  var monster = new Monster(spawner.char, spawner.color)\n  monster.name = spawner.name\n  monster.pointValue = spawner.pointValue\n  monster.hp = spawner.hp()\n  monster.hitChance = spawner.hitChance()\n  monster.hitDamage = spawner.hitDamage()\n  return monster\n}\n\nfunction Player(char, color, playerName) {\n  LivingEntity.call(this, char, color)\n\n  this.hp = 10\n  this.hitChance = 0.5\n  this.hitDamage = 2\n\n  this.visRadius = 7.5\n  this.attacking = false\n\n  this.name = playerName\n  this.score = 0\n\n  this.isWithinVisRadius = function isWithinVisRadius(i, j) {\n    return (this.x - j) ** 2 + (this.y - i) ** 2 < this.visRadius ** 2\n  }\n}\n\nmodule.exports = {\n  Monster,\n  Player\n}\n","var { charWidthPixels, charHeightPixels } = require('./charmap')\n\n// constants related to game dimensions and layout on screen\n\nvar canvasWidthChars = 80\nvar canvasHeightChars = 25\n\nvar canvasWidth = canvasWidthChars * charWidthPixels\nvar canvasHeight = canvasHeightChars * charHeightPixels\n\nvar mapWidth = 70\nvar mapHeight = 20\n\nvar statsWidth = canvasWidthChars - mapWidth\nvar statsHeight = mapHeight\n\nvar logWidth = canvasWidthChars\nvar logHeight = canvasHeightChars - mapHeight\n\nmodule.exports = {\n  canvasWidthChars,\n  canvasHeightChars,\n  canvasWidth,\n  canvasHeight,\n  mapWidth,\n  mapHeight,\n  statsWidth,\n  statsHeight,\n  logWidth,\n  logHeight\n}\n","var RandomRoomsMapGenerator = require('./mapgen/random-rooms-map-generator')\nvar BinarySpacePartitionMapGenerator = require('./mapgen/binary-space-partition-map-generator')\nvar RandomWalkMapGenerator = require('./mapgen/random-walk-map-generator')\n\nvar ErosionDungeonFeature = require('./mapgen/erosion-dungeon-feature')\nvar ErodedRoomDungeonFeature = require('./mapgen/eroded-room-dungeon-feature')\n\nvar { mapWidth, mapHeight } = require('./layout')\nvar { rollMonster } = require('./monsters')\nvar { Monster } = require('./entities')\nvar { randInt } = require('./utils')\n\nvar defaultTileColors = {\n  '#': '#666',\n  '.': '#ddd',\n  '<': '#ddd',\n  '>': '#ddd',\n}\n\nvar visBlock = {\n  '#': 0.05,\n  '.': 0.45,\n  '<': 0.45,\n  '>': 0.45,\n}\n\n// Is (x,y) visible from (x0,y0) in tile map level\nfunction isVisible(x, y, x0, y0, level) {\n  var m, xj, yj, yj_, xj_, j, dj, vbj_d, vbj_u, vb_d, vb_u\n  if (Math.abs(y - y0) <= Math.abs(x - x0)) {\n    // \"x-simple\"\n    m = (y - y0) / (x - x0)\n    dj = x < x0 ? -1 : 1\n    vb_d = 0\n    vb_u = 0\n    for (j = 0; Math.abs(j) < Math.abs(x - x0); j += dj) {\n      xj = x0 + j\n      yj = y0 + m * j\n\n      yj_ = Math.floor(yj)\n\n      // Calculate blocked portion of visiblity to both sides\n      vbj_d = 1 - (yj - yj_)\n      vbj_u = 1 - vbj_d\n\n      if (level[yj_][xj] == '#' && vbj_d > vb_d) {\n        vb_d = vbj_d\n      }\n      if (level[yj_ + 1][xj] == '#' && vbj_u > vb_u) {\n        vb_u = vbj_u\n      }\n      if (vb_d + vb_u > 1 - visBlock[level[y][x]]) {\n        return false\n      }\n    }\n  } else {\n    // \"y-simple\"\n    m = (x - x0) / (y - y0)\n    dj = y < y0 ? -1 : 1\n    vb_d = 0\n    vb_u = 0\n    for (j = 0; Math.abs(j) < Math.abs(y - y0); j += dj) {\n      yj = y0 + j\n      xj = x0 + m * j\n\n      xj_ = Math.floor(xj)\n\n      vbj_d = 1 - (xj - xj_)\n      vbj_u = 1 - vbj_d\n\n      if (level[yj][xj_] == '#' && vbj_d > vb_d) {\n        vb_d = vbj_d\n      }\n      if (level[yj][xj_ + 1] == '#' && vbj_u > vb_u) {\n        vb_u = vbj_u\n      }\n      if (vb_d + vb_u > 1 - visBlock[level[y][x]]) {\n        return false\n      }\n    }\n  }\n  return true\n}\n\nfunction Level(level) {\n  this.level = level\n\n  var chooseMapGenerator = Math.random()\n  if (chooseMapGenerator < 0.5) {\n    var generator = new RandomRoomsMapGenerator(level)\n  } else if (chooseMapGenerator < 0.9) {\n    var generator = new BinarySpacePartitionMapGenerator(level)\n  } else {\n    var generator = new RandomWalkMapGenerator(level)\n  }\n\n  generator.generate()\n  if (level > 0) {\n    generator.placeUpStaircase()\n  }\n  generator.placeDownStaircase()\n\n  this.map = generator.getFeatures()\n  this.tileMap = generator.getTileMap()\n\n  // Add a dungeon feature\n  var addFeature = Math.random() < 0.15\n  if (addFeature) {\n    var chooseFeature = Math.random()\n    if (chooseFeature < 0.5) {\n      var feature = new ErosionDungeonFeature()\n    } else {\n      var feature = new ErodedRoomDungeonFeature()\n    }\n    feature.addToLevel(generator)\n  }\n\n  this.colorMap = defaultTileColors\n\n  this.seenMask = this.tileMap.data.map(row => row.map(() => false))\n  this.isVisibleMask = this.tileMap.data.map(row => row.map(() => false))\n  this.wasVisibleMask = this.tileMap.data.map(row => row.map(() => false))\n  this.isOccupied = this.tileMap.data.map(row => row.map(tile => (tile == '#')))\n  this.canMonsterSpawn = this.tileMap.data.map(row => row.map(tile => (tile == '.')))\n\n  this.getRandomUnoccupiedTile = function getRandomUnoccupiedTile() {\n    var position\n    do {\n      position = { x: randInt(1, mapWidth - 2), y: randInt(1, mapHeight - 2) }\n    } while (!this.canMonsterSpawn[position.y][position.x])\n    return position\n  }\n\n  this.occupy = function occupy(position) {\n    this.isOccupied[position.y][position.x] = true\n  }\n\n  this.unoccupy = function unoccupy(position) {\n    this.isOccupied[position.y][position.x] = false\n  }\n\n  this.placePlayer = function placePlayer(player) {\n    this.occupy(player)\n    for (var i = 0; i < mapHeight; i++) {\n      for (var j = 0; j < mapWidth; j++) {\n        this.wasVisibleMask[i][j] = this.isVisibleMask[i][j]\n        if (player.isWithinVisRadius(i, j) &&\n            isVisible(j, i, player.x ,player.y, this.tileMap.data)) {\n          this.seenMask[i][j] = true\n          this.isVisibleMask[i][j] = true\n        } else {\n          this.isVisibleMask[i][j] = false\n        }\n      }\n    }\n  }\n\n  this.becameNotVisible = function becameNotVisible(i, j) {\n    return this.wasVisibleMask[i][j] && !this.isVisibleMask[i][j]\n  }\n\n  this.hasDownStaircase = function hasDownStaircase() {\n    return this.map.down\n  }\n  this.hasUpStaircase = function hasUpStaircase() {\n    return this.map.up\n  }\n  this.isDownStaircaseAt = function isDownStaircaseAt(position) {\n    return this.tileMap.at(position) == '>'\n  }\n  this.isUpStaircaseAt = function isUpStaircaseAt(position) {\n    return this.tileMap.at(position) == '<'\n  }\n  this.getDownStaircasePosition = function getDownStaircasePosition() {\n    if (this.hasDownStaircase()) {\n      return this.map.down\n    } else {\n      throw new Error('No down staircase in level')\n    }\n  }\n  this.getUpStaircasePosition = function getUpStaircasePosition() {\n    if (this.hasUpStaircase()) {\n      return this.map.up\n    } else {\n      throw new Error('No up staircase in level')\n    }\n  }\n\n  this.monsters = []\n  var numMonsters = 5 + this.level\n  for (var iMonster = 0; iMonster < numMonsters; iMonster++) {\n    var monsterType = rollMonster(this.level)\n    var monster = Monster.fromSpawner(monsterType)\n    var position = this.getRandomUnoccupiedTile()\n    monster.setPosition(position)\n    this.isOccupied[position.y][position.x] = true\n    this.monsters.push(monster)\n  }\n  this.getMonsterAt = function getMonsterAt(x, y) {\n    return this.monsters.find(m => m.x == x && m.y == y && m.hp > 0)\n  }\n}\n\nmodule.exports = Level\n","var {\n  logWidth,\n  logHeight\n} = require('./layout')\n\n// \"singleton\"\nfunction Logger() {\n  if (Logger.instance) {\n    throw new Error('Use Logger.getInstance')\n  }\n  Logger.instance = this\n  this.logBuffer = [\n    'Very long line with monsters attacking and all sorts of crazy stuff going on so that this has to be split into multiple lines for sure'\n  ]\n  this.maxLineWidth = logWidth - 2 // '> ' prefix\n  this.lineRegex = new RegExp(`(.{0,${this.maxLineWidth}}$|.{0,${this.maxLineWidth}}\\\\b)`, 'g')\n\n  this.newLine = ''\n  this.appendToLine = function appendToLine(msg) {\n    if (this.newLine.length == 0) {\n      this.newLine += msg\n    } else {\n      this.newLine += (' ' + msg)\n    }\n  }\n  this.finishLine = function finishLine() {\n    if (this.newLine.length > 0) {\n      this.logBuffer.unshift(this.newLine)\n    }\n    this.newLine = ''\n  }\n\n  this.getLogLines = function* getLogLines() {\n    var linesToDisplay = []\n    var iLine = 0\n    while (linesToDisplay.length < logHeight) {\n      if (iLine < this.logBuffer.length) {\n        var line = this.logBuffer[iLine]\n        var split = line.match(this.lineRegex)\n          .map(part => part.trim())\n          .filter(part => part.length > 0)\n        for (var iPart = split.length - 1; iPart > 0; iPart--) {\n          var part = '  ' + split[iPart]\n          linesToDisplay.push(part)\n        }\n        var firstPart = '> ' + split[0]\n        linesToDisplay.push(firstPart)\n      } else {\n        linesToDisplay.push('  ')\n      }\n      iLine += 1\n    }\n    iLine = 0\n    while (iLine < logHeight) {\n      var line = linesToDisplay[iLine]\n      yield line.padEnd(logWidth, ' ')\n      iLine += 1\n    }\n  }\n\n  this.clearBuffer = function clearBuffer() {\n    this.logBuffer = []\n  }\n}\nLogger.getInstance = function getInstance() {\n  return Logger.instance || new Logger()\n}\n\nmodule.exports = Logger\n","var { mapWidth, mapHeight } = require('../layout')\n\nfunction DungeonFeature() {\n  this.isApplicableTo = function isApplicableTo(level) {\n    throw new Error('Use one of the child classes')\n  }\n\n  this.addToLevel = function addToLevel(level) {\n    throw new Error('Use one of the child classes')\n  }\n}\n\nmodule.exports = DungeonFeature\n","var TileMap = require('../tilemap')\n\nvar { mapWidth, mapHeight } = require('../layout')\n\nfunction MapGenerator(level) {\n  this.level = level\n\n  this.mapWidth = mapWidth\n  this.mapHeight = mapHeight\n  this.mapArea = this.mapWidth * this.mapHeight\n\n  // this.tileMap = MapGenerator.createEmptyTileMap()\n  this.tileMap = new TileMap(this.mapWidth, this.mapHeight)\n\n  this.features = {}\n\n  this.generate = function generate() {\n    throw new Error('Use one of the child classes')\n  }\n\n  this.getTileMap = function getTileMap() {\n    return this.tileMap\n  }\n\n  this.getFeatures = function getFeatures() {\n    throw new Error('Use one of the child classes')\n  }\n\n  this.placeDownStaircase = function placeDownStaircase() {\n    throw new Error('Use one of the child classes')\n  }\n\n  this.placeUpStaircase = function placeUpStaircase() {\n    throw new Error('Use one of the child classes')\n  }\n\n  // general tilemap related functionality\n  this.advanceTo = function advanceTo(pt, dir) {\n    var pt1 = this.tileMap.toDir(pt, dir)\n    if (this.tileMap.inBounds(pt1)) {\n      return pt1\n    } else {\n      return null\n    }\n  }\n\n  // for debugging\n  this.print = function print() {\n    this.tileMap.print()\n  }\n}\n\nMapGenerator.createEmptyTileMap = function createEmptyTileMap(char = '#') {\n  var tileMap = Array(mapHeight)\n  for (var i = 0; i < mapHeight; i++) {\n    tileMap[i] = Array(mapWidth)\n    for (var j = 0; j < mapWidth; j++) {\n      tileMap[i][j] = char\n    }\n  }\n  return tileMap\n}\n\nmodule.exports = MapGenerator\n","var MapGenerator = require('./abstract-map-generator')\nvar { Room } = require('./mapgen-commons')\nvar { randFloat, randInt } = require('../utils')\n\nconst AXIS_HORIZONTAL = 1\nconst AXIS_VERTICAL = 2\n\nvar params = {\n  minRoomWidth: 5,\n  maxRoomWidth: 15,\n  minRoomHeight: 3,\n  maxRoomHeight: 7,\n\n  maxNumberOfRooms: 10,\n  targetMapFillRatio: 0.33,\n  maxFailuresToAddRoom: 100,\n\n  minSplitRatio: 0.2,\n  maxSplitRatio: 0.8,\n\n  partitionWidthThreshold: 19,\n  partitionHeightThreshold: 14\n}\n\nfunction Node(top, left, width, height) {\n  this.top = top\n  this.left = left\n  this.width = width\n  this.height = height\n\n  this.parent = null\n  this.splitAxis = null // split axis of parent\n  this.firstChild = null\n  this.secondChild = null\n\n  this.room = null\n\n  this.isLeafNode = function isLeafNode() {\n    return this.firstChild == null && this.secondChild == null\n  }\n\n  this.canContainRoom = function canContainRoom() {\n    return this.width >= params.minRoomWidth + 2 && this.height >= params.minRoomHeight + 2\n  }\n\n  this.hasRoom = function hasRoom() {\n    return this.room != null\n  }\n\n  this.clone = function clone() {\n    return new Node(this.top, this.left, this.width, this.height)\n  }\n\n  this.splitAlongHorizontal = function splitAlongHorizontal(ratio) {\n    var upperHeight = Math.floor(ratio * this.height)\n\n    var upperPart = this.clone()\n    upperPart.splitAxis = AXIS_HORIZONTAL\n    upperPart.height = upperHeight\n    this.firstChild = upperPart\n    upperPart.parent = this\n\n    var lowerPart = this.clone()\n    lowerPart.splitAxis = AXIS_HORIZONTAL\n    lowerPart.top = upperPart.top + upperHeight\n    lowerPart.height = this.height - upperHeight\n    this.secondChild = lowerPart\n    lowerPart.parent = this\n\n    return [upperPart, lowerPart]\n  }\n\n  this.splitAlongVertical = function splitAlongVertical(ratio) {\n    var leftWidth = Math.floor(ratio * this.width)\n\n    var leftPart = this.clone()\n    leftPart.splitAxis = AXIS_VERTICAL\n    leftPart.width = leftWidth\n    this.firstChild = leftPart\n    leftPart.parent = this\n\n    var rightPart = this.clone()\n    rightPart.splitAxis = AXIS_VERTICAL\n    rightPart.left = leftPart.left + leftWidth\n    rightPart.width = this.width - leftWidth\n    this.secondChild = rightPart\n    rightPart.parent = this\n\n    return [leftPart, rightPart]\n  }\n\n  this.split = function split(ratio) {\n    var splitAlongHorizontal\n    if (this.width < params.partitionWidthThreshold) {\n      splitAlongHorizontal = true\n    } else if (this.height < params.partitionHeightThreshold) {\n      splitAlongHorizontal = false\n    } else {\n      splitAlongHorizontal = Math.random() < this.height / (this.width + this.height)\n    }\n\n    if (splitAlongHorizontal) {\n      return this.splitAlongHorizontal(ratio)\n    } else {\n      return this.splitAlongVertical(ratio)\n    }\n  }\n\n  this.getDescendantRooms = function getDescendantRooms() {\n    var rooms = []\n    if (this.hasRoom()) {\n      rooms.push(this.room)\n    }\n    if (!this.isLeafNode()) {\n      rooms = rooms.concat(this.firstChild.getDescendantRooms())\n      rooms = rooms.concat(this.secondChild.getDescendantRooms())\n    }\n    return rooms\n  }\n}\n\nfunction BinarySpacePartitionMapGenerator(level) {\n  MapGenerator.call(this, level)\n\n  this.rooms = []\n  this.corridors = []\n  this.features = {}\n\n  var self = this\n\n  this.generate = function generate() {\n    var nodes = [\n      new Node(0, 0, this.mapWidth, this.mapHeight)\n    ]\n    function split(node) {\n      if (node.width < params.partitionWidthThreshold && node.height < params.partitionHeightThreshold) {\n        return\n      } else {\n        var splitRatio = randFloat(params.minSplitRatio, params.maxSplitRatio)\n        var children = node.split(splitRatio)\n        children.forEach(child => {\n          nodes.push(child)\n          split(child)\n        })\n      }\n    }\n\n    split(nodes[0])\n\n    nodes.forEach(node => {\n      if (node.isLeafNode() && node.canContainRoom()) {\n        var roomWidth = randInt(params.minRoomWidth, node.width - 2)\n        var roomHeight = randInt(params.minRoomHeight, node.height - 2)\n        var roomLeft = randInt(node.left + 1, node.left + node.width - 1 - (roomWidth + 1))\n        var roomTop = randInt(node.top + 1, node.top + node.height - 1 - (roomHeight + 1))\n\n        node.room = new Room(roomTop, roomLeft, roomWidth, roomHeight)\n\n        self.rooms.push(node.room)\n        self.carveRoom(node.room)\n      }\n    })\n\n    function connectDescendants(node) {\n      if (node.isLeafNode()) {\n        return\n      }\n      var firstRooms = node.firstChild.getDescendantRooms()\n      var secondRooms = node.secondChild.getDescendantRooms()\n      var minDistance = Infinity\n      var firstRoom = null\n      var secondRoom = null\n      firstRooms.forEach(room1 => {\n        secondRooms.forEach(room2 => {\n          var distance = room1.distanceTo(room2)\n          if (distance < minDistance) {\n            firstRoom = room1\n            secondRoom = room2\n            minDistance = distance\n          }\n        })\n      })\n      if (firstRoom && secondRoom) {\n        [firstLeg, secondLeg] = firstRoom.getCorridorTo(secondRoom)\n        self.corridors.push(firstLeg)\n        self.corridors.push(secondLeg)\n        self.carveRoom(firstLeg)\n        self.carveRoom(secondLeg)\n      }\n      connectDescendants(node.firstChild)\n      connectDescendants(node.secondChild)\n    }\n\n    connectDescendants(nodes[0])\n  }\n\n  this.carveRoom = function carveRoom(room) {\n    for (var i = room.top; i < room.top + room.height; i++) {\n      for (var j = room.left; j < room.left + room.width; j++) {\n        var pt = { x: j, y: i }\n        this.tileMap.put(pt, '.')\n      }\n    }\n  }\n\n  this.getFeatures = function getFeatures() {\n    return {\n      rooms: this.rooms,\n      corridors: this.corridors,\n      up: this.features.up,\n      down: this.features.down\n    }\n  }\n\n  this.placeStaircase = function placeStaircase(direction) {\n    var roomInd = randInt(0, this.rooms.length - 1)\n    var position = this.rooms[roomInd].getRandomPosition()\n    this.features[direction] = position\n    this.tileMap.put(position, direction == 'up' ? '<' : '>')\n  }\n\n  this.placeDownStaircase = function placeDownStaircase() {\n    this.placeStaircase('down')\n  }\n\n  this.placeUpStaircase = function placeUpStaircase() {\n    this.placeStaircase('up')\n  }\n}\n\nmodule.exports = BinarySpacePartitionMapGenerator\n","var DungeonFeature = require('./abstract-dungeon-feature')\n\nvar { randInt } = require('../utils')\n\nvar params = {\n  minErodedTiles: 10,\n  maxErodedTiles: 100\n}\n\nfunction ErodedRoomDungeonFeature() {\n  DungeonFeature.call(this)\n\n  this.addToLevel = function addToLevel(generator) {\n    if (!generator.rooms || generator.rooms.length == 0) {\n      console.log('not room-based dungoen')\n      return\n    }\n    var roomInd = randInt(0, generator.rooms.length - 1)\n    var room = generator.rooms[roomInd]\n    var numErodedTiles = randInt(params.minErodedTiles, params.maxErodedTiles)\n    for (var i = 0; i < numErodedTiles; i++) {\n      var dir = randInt(0, 7)\n      // rays along the diagonal can start from two possible edges\n      var edge = dir % 2 == 0 ? dir / 2 : randInt((dir - 1) / 2, (dir - 1) / 2 + 1)\n      edge = edge % 4\n      var pt = room.getRandomEdgePosition(edge)\n      do {\n        pt = generator.advanceTo(pt, dir)\n      } while (pt && generator.tileMap.at(pt) == '.')\n      if (pt) {\n        generator.tileMap.put(pt, '.')\n      }\n    }\n  }\n}\n\nmodule.exports = ErodedRoomDungeonFeature\n","var DungeonFeature = require('./abstract-dungeon-feature')\n\nvar { randInt } = require('../utils')\n\nvar params = {\n  minErodedTiles: 100,\n  maxErodedTiles: 300\n}\n\nfunction ErosionDungeonFeature() {\n  DungeonFeature.call(this)\n\n  this.addToLevel = function addToLevel(generator) {\n    var numErodedTiles = randInt(params.minErodedTiles, params.maxErodedTiles)\n    for (var i = 0; i < numErodedTiles; i++) {\n      do {\n        var pt = { x: randInt(1, generator.mapWidth - 2), y: randInt(1, generator.mapHeight - 2) }\n        var adjacent = [\n          { x: pt.x - 1, y: pt.y },\n          { x: pt.x, y: pt.y - 1 },\n          { x: pt.x + 1, y: pt.y },\n          { x: pt.x, y: pt.y + 1 }\n        ]\n      } while (generator.tileMap.at(pt) != '#' || adjacent.every(p => generator.tileMap.at(p) == '#'))\n      generator.tileMap.put(pt, '.')\n    }\n  }\n}\n\nmodule.exports = ErosionDungeonFeature\n","var { randInt } = require('../utils')\n\nfunction Room(top, left, width, height) {\n  this.top = top\n  this.left = left\n  this.width = width\n  this.height = height\n\n  this.connected = false\n\n  this.area = function area() {\n    return this.width * this.height\n  }\n\n  this.getRandomPosition = function getRandomPosition() {\n    return {\n      x: randInt(this.left, this.left + this.width - 1),\n      y: randInt(this.top, this.top + this.height - 1)\n    }\n  }\n\n  this.getRandomEdgePosition = function getRandomEdgePosition(edge) {\n    // edge: 0 north, 1 east, 2 south, 3 west\n    var pt = { x: 0, y: 0 }\n    if (edge == 0) {\n      pt.x = this.left + randInt(0, this.width - 1)\n      pt.y = this.top\n    } else if (edge == 1) {\n      pt.x = this.left + this.width - 1\n      pt.y = this.top + randInt(0, this.height - 1)\n    } else if (edge == 2) {\n      pt.x = this.left + randInt(0, this.width - 1)\n      pt.y = this.top + this.height - 1\n    } else if (edge == 3) {\n      pt.x = this.left\n      pt.y = this.top + randInt(0, this.height - 1)\n    }\n    return pt\n  }\n\n  this.overlapsX = function overlapsX(that) {\n    return (\n      that.left - this.width <= this.left &&\n      this.left <= that.left + that.width\n    )\n  }\n\n  this.overlapsY = function overlapsY(that) {\n    return (\n      that.top - this.height <= this.top &&\n      this.top <= that.top + that.height\n    )\n  }\n\n  this.overlaps = function overlaps(that) {\n    return this.overlapsX(that) && this.overlapsY(that)\n  }\n\n  this.xDistanceTo = function xDistanceTo(that) {\n    if (!this.overlapsX(that)) {\n      return Math.min(Math.abs(this.left + this.width - that.left), Math.abs(that.left + that.width - this.left))\n    } else {\n      return 0\n    }\n  }\n\n  this.yDistanceTo = function yDistanceTo(that) {\n    if (!this.overlapsY(that)) {\n      return Math.min(Math.abs(this.top + this.height - that.top), Math.abs(that.top + that.height - this.top))\n    } else {\n      return 0\n    }\n  }\n\n  this.distanceTo = function distanceTo(that) {\n    return this.xDistanceTo(that) + this.yDistanceTo(that)\n  }\n\n  // Two-segment corridor\n  this.getCorridorTo = function getCorridorTo(that) {\n    var pSrc = this.getRandomPosition()\n    var xSrc = pSrc.x\n    var ySrc = pSrc.y\n    var pDest = that.getRandomPosition()\n    var xDest = pDest.x\n    var yDest = pDest.y\n\n    var verticalFirst = Math.random() < 0.5\n    var xTurn, yTurn\n    if (verticalFirst) {\n      xTurn = xSrc\n      yTurn = yDest\n    } else {\n      xTurn = xDest\n      yTurn = ySrc\n    }\n\n    var firstLeg, secondLeg\n    if (verticalFirst) {\n      firstLeg = new Room(Math.min(ySrc, yDest), xSrc, 1, Math.abs(ySrc - yDest) + 1)\n      secondLeg = new Room(yDest, Math.min(xSrc, xDest), Math.abs(xSrc - xDest) + 1, 1)\n    } else {\n      firstLeg = new Room(ySrc, Math.min(xSrc, xDest), Math.abs(xSrc - xDest) + 1, 1)\n      secondLeg = new Room(Math.min(ySrc, yDest), xDest, 1, Math.abs(ySrc - yDest) + 1)\n    }\n\n    return [firstLeg, secondLeg]\n  }\n}\n\nmodule.exports = {\n  Room\n}\n","var MapGenerator = require('./abstract-map-generator')\nvar { Room } = require('./mapgen-commons')\n\nvar { randInt } = require('../utils')\n\nvar params = {\n  minRoomWidth: 5,\n  maxRoomWidth: 15,\n  minRoomHeight: 3,\n  maxRoomHeight: 7,\n\n  maxNumberOfRooms: 10,\n  targetMapFillRatio: 0.33,\n  maxFailuresToAddRoom: 100,\n\n  erosionChance: 0.25,\n  minErodedTiles: 100,\n  maxErodedTiles: 300\n}\n\nfunction RandomRoomsMapGenerator(level) {\n  MapGenerator.call(this, level)\n\n  this.rooms = []\n  this.corridors = []\n\n  this.generate = function generate() {\n    var addMoreRooms = true\n    var failuresToAddRoom = 0\n    var totalRoomArea = 0\n\n    while (addMoreRooms) {\n      var width = randInt(params.minRoomWidth, params.maxRoomWidth)\n      var height = randInt(params.minRoomHeight, params.maxRoomHeight)\n\n      var left = randInt(1, this.mapWidth - 1 - (width + 1))\n      var top = randInt(1, this.mapHeight - 1 - (height + 1))\n\n      var roomCandidate = new Room(top, left, width, height)\n\n      var overlapsOtherRooms = false\n      for (var iRoom = 0; iRoom < this.rooms.length; iRoom++) {\n        var room = this.rooms[iRoom]\n        if (room.overlaps(roomCandidate)) {\n          overlapsOtherRooms = true\n          break\n        }\n      }\n      if (overlapsOtherRooms) {\n        failuresToAddRoom += 1\n        if (failuresToAddRoom > params.maxFailuresToAddRoom) {\n          addMoreRooms = false\n        }\n        continue\n      }\n\n      this.rooms.push(roomCandidate)\n\n      totalRoomArea += roomCandidate.area()\n      if (totalRoomArea / this.mapArea > params.targetMapFillRatio || this.rooms.length > params.maxNumberOfRooms) {\n        addMoreRooms = false\n      }\n    }\n\n    this.placeRandomCorridors()\n\n    this.updateTileMap()\n  }\n\n  this.isBrushing = function isBrushing(candidate) {\n    function roomBrushesCorridor(room, corridor) {\n      if (corridor.width > 1 && ((corridor.top == room.top - 1) || (corridor.top == room.top + room.height))) {\n        return corridor.overlapsX(room) || (corridor.left == room.left + room.width) || (corridor.left + corridor.width == room.left)\n      } else if (corridor.height > 1 && ((corridor.left == room.left - 1) || (corridor.left == room.left + room.width))) {\n        return corridor.overlapsY(room) || (corridor.top == room.top + room.height) || (corridor.top + corridor.height == room.top)\n      }\n    }\n    for (var room of this.rooms) {\n      if (roomBrushesCorridor(room, candidate)) {\n        return true\n      }\n    }\n    for (var corridor of this.corridors) {\n      if (corridor.width == candidate.width && (corridor.left == candidate.left - 1 || corridor.left == candidate.left + 1)) {\n        return true\n      }\n      if (corridor.height == candidate.height && (corridor.top == candidate.top - 1 || corridor.top == candidate.top + 1)) {\n        return true\n      }\n    }\n    return false\n  }\n\n  this.placeRandomCorridors = function placeRandomCorridors() {\n    var iSrc = -1\n    var iDest\n    do {\n      iSrc++\n      iDest = iSrc + 1\n      iDest = iDest % this.rooms.length\n      while (this.rooms[iDest].connected) {\n        iDest++\n        if (iDest >= this.rooms.length) {\n          iDest = 0\n        }\n      }\n      var srcRoom = this.rooms[iSrc]\n      var destRoom = this.rooms[iDest]\n\n      var corridorAttempt = 0\n      var corridorFound = false\n      var isBrushing = true\n      while (isBrushing && corridorAttempt < 10) {\n        var [firstLeg, secondLeg] = srcRoom.getCorridorTo(destRoom)\n        isBrushing = this.isBrushing(firstLeg) || this.isBrushing(secondLeg)\n        if (!isBrushing) {\n          corridorFound = true\n          break\n        }\n        corridorAttempt++\n      }\n\n      if (corridorFound) {\n        this.corridors.push(firstLeg)\n        this.corridors.push(secondLeg)\n\n        srcRoom.connected = true\n        destRoom.connected = true\n\n        for (var iRoom = 0; iRoom < this.rooms.length; iRoom++) {\n          var room = this.rooms[iRoom]\n          if (room.connected) {\n            continue\n          }\n          if (room.overlaps(firstLeg) || room.overlaps(secondLeg)) {\n            room.connected = true\n          }\n        }\n      }\n    } while (this.rooms.some(room => !room.connected))\n  }\n\n  this.carveRoom = function carveRoom(room, char = '.') {\n    for (var i = room.top; i < room.top + room.height; i++) {\n      for (var j = room.left; j < room.left + room.width; j++) {\n        var pt = { x: j, y: i }\n        this.tileMap.put(pt, char)\n      }\n    }\n  }\n\n  this.updateTileMap = function updateTileMap() {\n    this.rooms.forEach((room, ind) => {\n      this.carveRoom(room, '.')\n    })\n    this.corridors.forEach((corridor) => {\n      this.carveRoom(corridor)\n    })\n  }\n\n  this.getFeatures = function getFeatures() {\n    return {\n      rooms: this.rooms,\n      corridors: this.corridors,\n      up: this.features.up,\n      down: this.features.down\n    }\n  }\n\n  this.placeStaircase = function placeStaircase(direction) {\n    var roomInd = randInt(0, this.rooms.length - 1)\n    var position = this.rooms[roomInd].getRandomPosition()\n    this.features[direction] = position\n    this.tileMap.put(position, direction == 'up' ? '<' : '>')\n  }\n\n  this.placeDownStaircase = function placeDownStaircase() {\n    this.placeStaircase('down')\n  }\n\n  this.placeUpStaircase = function placeUpStaircase() {\n    this.placeStaircase('up')\n  }\n}\n\nmodule.exports = RandomRoomsMapGenerator\n","var MapGenerator = require('./abstract-map-generator')\n\nvar { randInt } = require('../utils')\n\nvar params = {\n  targetMapFillRatio: 0.33,\n  maxWalkLength: 10000\n}\n\nfunction RandomWalkMapGenerator(level) {\n  MapGenerator.call(this, level)\n\n  this.walkCoverage = MapGenerator.createEmptyTileMap(false);\n  var coverageUnit = 1 / (this.mapWidth * this.mapHeight)\n\n  this.generate = function generate() {\n    var pt = { x: Math.round(this.mapWidth / 2), y: Math.round(this.mapHeight / 2) }\n    this.walkCoverage[pt.y][pt.x] = true\n    var coverageFraction = coverageUnit\n    var horizontalProb = (this.mapWidth) / (this.mapWidth + this.mapHeight)\n    console.log('horizontal prob', horizontalProb)\n    function getRandomDirection() {\n      var dirHorizontal = Math.random() < horizontalProb\n      if (dirHorizontal) {\n        var dir = randInt(0, 1) * 2 + 1 // 1 or 3\n      } else {\n        var dir = randInt(0, 1) * 2\n      }\n      return dir\n    }\n    var dir = getRandomDirection()\n    var walkLength = 0\n    while (coverageFraction < params.targetMapFillRatio && walkLength < params.maxWalkLength) {\n      var didMove = false\n      if (dir == 0) {\n        if (pt.y > 1) {\n          pt.y--\n          didMove = true\n        } else {\n          dir = 2 // bounce off the edge\n        }\n      } else if (dir == 1) {\n        if (pt.x < this.mapWidth - 2) {\n          pt.x++\n          didMove = true\n        } else {\n          dir = 3\n        }\n      } else if (dir == 2) {\n        if (pt.y < this.mapHeight - 2) {\n          pt.y++\n          didMove = true\n        } else {\n          dir = 0\n        }\n      } else if (dir == 3) {\n        if (pt.x > 1) {\n          pt.x--\n          didMove = true\n        } else {\n          dir = 1\n        }\n      }\n      if (!this.walkCoverage[pt.y][pt.x]) {\n        this.walkCoverage[pt.y][pt.x] = true\n        coverageFraction += coverageUnit\n      }\n      this.tileMap.put(pt, '.')\n      walkLength++\n\n      if (didMove) { dir = getRandomDirection() }\n    }\n    console.log(`cov ${coverageFraction}, walk ${walkLength}`)\n  }\n\n  this.placeStaircase = function placeStaircase(direction) {\n    do {\n      var pt = { x: randInt(0, this.mapWidth - 1), y: randInt(0, this.mapHeight - 1) }\n    } while (!this.walkCoverage[pt.y][pt.x])\n    this.features[direction] = pt\n    this.tileMap.put(pt, direction == 'up' ? '<' : '>')\n  }\n\n  this.placeDownStaircase = function placeDownStaircase() {\n    this.placeStaircase('down')\n  }\n\n  this.placeUpStaircase = function placeUpStaircase() {\n    this.placeStaircase('up')\n  }\n\n  this.getFeatures = function getFeatures() {\n    return {\n      up: this.features.up,\n      down: this.features.down\n    }\n  }\n}\n\nmodule.exports = RandomWalkMapGenerator\n","var { randInt } = require('./utils')\n\nvar monsterDictionary = [\n  {\n    name: 'small monster',\n    char: 'g',\n    color: '#f00',\n    pointValue: level => level * 1 + 1,\n    spawnWeight: level => 1 / (level + 1),\n    hp: level => [1, 1],\n    hitChance: level => [10, 20],\n    hitDamage: level => [1, 1]\n  },\n  {\n    name: 'monster',\n    char: 'g',\n    color: '#a00',\n    pointValue: level => level * 2 + 2,\n    spawnWeight: level => 1.0,\n    hp: level => [1, 1 + Math.floor(level / 2)],\n    hitChance: level => [10 + level, 20 + 2 * level],\n    hitDamage: level => [1, 1 + Math.floor(level / 4)]\n  },\n  {\n    name: 'large monster',\n    char: 'G',\n    color: '#a50',\n    pointValue: level => level * 3 + 3,\n    spawnWeight: level => level / 20,\n    hp: level => [5, 5 + level],\n    hitChance: level => [10 + level, 20 + 2 * level],\n    hitDamage: level => [2, 2 + Math.floor(level / 2)]\n  },\n  {\n    name: 'huge monster',\n    char: 'G',\n    color: '#840',\n    pointValue: level => level * 4 + 4,\n    spawnWeight: level => level / 500,\n    hp: level => [10, 10 + level],\n    hitChance: level => [20 + level, 30 + 2 * level],\n    hitDamage: level => [4, 4 + level]\n  }\n]\n\nfunction generateSpawnerFrom(entry, level) {\n  var hpBounds = entry.hp(level)\n  var hitChanceBounds = entry.hitChance(level)\n  var hitDamageBounds = entry.hitDamage(level)\n  var pointValue = entry.pointValue(level)\n  return {\n    name: entry.name,\n    char: entry.char,\n    color: entry.color,\n    pointValue,\n    hp: () => randInt(hpBounds[0], hpBounds[1]),\n    hitChance: () => randInt(hitChanceBounds[0], hitChanceBounds[1]) / 100,\n    hitDamage: () => randInt(hitDamageBounds[0], hitDamageBounds[1])\n  }\n}\n\nfunction rollMonster(level) {\n  var roll = Math.random()\n  var weightSum = monsterDictionary.reduce((acc, curr) => acc + curr.spawnWeight(level), 0)\n  var cumulativeWeight = 0\n  for (var i = 0; i < monsterDictionary.length; i++) {\n    var entry = monsterDictionary[i]\n    cumulativeWeight += entry.spawnWeight(level) / weightSum\n    if (roll < cumulativeWeight) {\n      var spawner = generateSpawnerFrom(entry, level)\n      return spawner\n    }\n  }\n}\n\nmodule.exports = {\n  rollMonster,\n}\n","var {\n  charOffsetX,\n  charOffsetY,\n  charWidthPixels,\n  charHeightPixels,\n  charMap\n} = require('./charmap')\n\nvar {\n  canvasWidth,\n  canvasHeight\n} = require('./layout')\n\nfunction Renderer(id, top, left, width, height) {\n  this.id = id\n\n  this.top = top\n  this.left = left\n  this.width = width\n  this.height = height\n\n  this.context = null\n\n  this.init = function init(container, charSheet) {\n    var canvas = document.createElement('canvas')\n    canvas.className = 'game-canvas'\n    canvas.setAttribute('id', id)\n    canvas.setAttribute('width', canvasWidth)\n    canvas.setAttribute('height', canvasHeight)\n    canvas.style.transform = `translate(${canvasWidth / 2}px,${canvasHeight / 2}px)scale(2)`\n    container.appendChild(canvas)\n\n    this.context = canvas.getContext('2d')\n    this.charSheet = charSheet\n\n    return this\n  }\n\n  this.clear = function clear() {\n    this.context.clearRect(0, 0, canvasWidth, canvasHeight)\n  }\n\n  this.drawChar = function drawChar(char, i, j) {\n    if (!(char in charMap)) {\n      throw new Error('invalid char: ' + char)\n    }\n    this.context.drawImage(\n      this.charSheet,\n      charOffsetX + charMap[char].j * charWidthPixels,\n      charOffsetY + charMap[char].i * charHeightPixels,\n      charWidthPixels,\n      charHeightPixels,\n      (this.left + j) * charWidthPixels,\n      (this.top + i) * charHeightPixels,\n      charWidthPixels,\n      charHeightPixels\n    )\n  }\n\n  this.drawText = function drawText(text, color, i, j) {\n    // negative i means count lines from bottom\n    for (var k = 0; k < text.length; k++) {\n      this.drawColoredChar(text[k], color, i >= 0 ? i : this.height + i, j + k)\n    }\n  }\n\n  this.drawTile = function drawTile(color, i, j) {\n    this.context.fillStyle = color\n    this.context.fillRect(\n      (this.left + j) * charWidthPixels,\n      (this.top + i) * charHeightPixels,\n      charWidthPixels,\n      charHeightPixels\n    )\n  }\n\n  this.clearTile = function clearTile(i, j) {\n    this.context.clearRect(\n      (this.left + j) * charWidthPixels,\n      (this.top + i) * charHeightPixels,\n      charWidthPixels,\n      charHeightPixels\n    )\n  }\n\n  this.drawColoredChar = function drawColoredChar(char, color, i, j) {\n    this.drawTile(color, i, j)\n    this.drawChar(char, i, j)\n  }\n\n  this.fillWithChar = function fillWithChar(char) {\n    for (var i = 0; i < this.height; i++) {\n      for (var j = 0; j < this.width; j++) {\n        this.drawChar(char, i, j)\n      }\n    }\n  }\n}\n\nmodule.exports = Renderer\n","var allDirections = [0, 1, 2, 3, 4, 5, 6, 7]\nvar cardinalDirections = [0, 2, 4, 6]\n\nfunction TileMap(mapWidth, mapHeight, char) {\n  this.mapWidth = mapWidth\n  this.mapHeight = mapHeight\n\n  this.data = TileMap.create(this.mapWidth, this.mapHeight, char)\n\n  this.at = function at(pt) {\n    return this.data[pt.y][pt.x]\n  }\n\n  this.put = function put(pt, char) {\n    this.data[pt.y][pt.x] = char\n  }\n\n  this.inBounds = function inBounds(pt) {\n    return (pt.x > 0 && pt.x < this.mapWidth - 1 && pt.y > 0 && pt.y < this.mapHeight)\n  }\n\n  // directions 0: north, 1: northeast, 2: east, ..., 7: northwest\n  this.toDir = function toDir(pt, dir) {\n    var pt1\n    if (dir == 0) {\n      pt1 = { x: pt.x, y: pt.y - 1 }\n    } else if (dir == 1) {\n      pt1 = { x: pt.x + 1, y: pt.y - 1 }\n    } else if (dir == 2) {\n      pt1 = { x: pt.x + 1, y: pt.y }\n    } else if (dir == 3) {\n      pt1 = { x: pt.x + 1, y: pt.y + 1 }\n    } else if (dir == 4) {\n      pt1 = { x: pt.x, y: pt.y + 1 }\n    } else if (dir == 5) {\n      pt1 = { x: pt.x - 1, y: pt.y + 1 }\n    } else if (dir == 6) {\n      pt1 = { x: pt.x - 1, y: pt.y }\n    } else if (dir == 7) {\n      pt1 = { x: pt.x - 1, y: pt.y - 1 }\n    }\n    return pt1\n  }\n\n  this.atDir = function atDir(pt, dir) {\n    var pt1 = this.toDir(pt, dir)\n    return this.at(pt1)\n  }\n\n  this.atDirs = function atDirs(pt, dirs) {\n    return dirs.map(dir => this.atDir(pt, dir))\n  }\n\n  this.aroundDir = function aroundDir(pt, dir) {\n    // what would be an efficient way to view environments?\n    if (dir >= 0) {\n      var dirs = [dir - 1, dir, dir + 1].map(d => {\n        var dd = d % 8\n        if (dd < 0) {\n          dd += 8\n        }\n        return dd\n      })\n    } else {\n      var dirs = [0, 1, 2, 3, 4, 5, 6, 7]\n    }\n    return this.atDirs(pt, dirs)\n  }\n\n  // for wayfinding\n  this.accessibleEnvironment = function accessibleEnvironment(pt) {\n    var points = allDirections.map(dir => this.toDir(pt, dir)).filter(this.inBounds.bind(this))\n    var accessiblePoints = points.filter(p => this.at(p) == '.')\n    return accessiblePoints\n  }\n\n  this.print = function print() {\n    for (var i = 0; i < this.mapHeight; i++) {\n      console.log(this.data[i].join(''))\n    }\n  }\n\n  this.copy = function copy() {\n    var copy = new TileMap(this.mapWidth, this.mapHeight)\n    for (var i = 0; i < this.mapHeight; i++) {\n      for (var j = 0; j < this.mapWidth; j++) {\n        var pt = { x: j, y: i }\n        copy.put(pt, this.at(pt))\n      }\n    }\n    return copy\n  }\n}\n\nTileMap.create = function create(width, height, char = '#') {\n  var arr = Array(height)\n  for (var i = 0; i < height; i++) {\n    arr[i] = Array(width)\n    for (var j = 0; j < width; j++) {\n      arr[i][j] = char\n    }\n  }\n  return arr\n}\n\nTileMap.fromString = function fromString(str) {\n  var rows = str.split('\\n').filter(row => row.length > 0)\n  if (rows.some(row => row.length != rows[0].length)) {\n    throw new Error('Invalid tile map string')\n  }\n  var mapWidth = rows[0].length\n  var mapHeight = rows.length\n  var tileMap = new TileMap(mapWidth, mapHeight)\n  for (var i = 0; i < mapHeight; i++) {\n    for (var j = 0; j < mapWidth; j++) {\n      var pt = { x: j, y: i }\n      tileMap.put(pt, rows[i][j])\n    }\n  }\n  return tileMap\n}\n\nmodule.exports = TileMap\n","function randInt(n0, n1) {\n  return n0 + Math.floor((n1 - n0 + 1) * Math.random())\n}\n\nfunction randFloat(f0, f1) {\n  return f0 + Math.random() * (f1 - f0)\n}\n\nfunction tossACoin() {\n  return Math.random() < 0.5\n}\n\nmodule.exports = {\n  randInt,\n  randFloat\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","var Logger = require('./logger')\nvar Renderer = require('./renderer')\nvar Level = require('./level')\nvar { Player } = require('./entities')\n\nvar GAME_VERSION = '0.0.2'\n\nvar {\n  canvasWidthChars,\n  canvasHeightChars,\n  mapWidth,\n  mapHeight,\n  statsWidth,\n  statsHeight,\n  logWidth,\n  logHeight\n} = require('./layout')\n\nvar defaultTextColor = '#aaa'\n\nfunction createCanvasContainer() {\n  var div = document.createElement('div')\n  div.className = 'container'\n  document.body.appendChild(div)\n  return div\n}\n\nvar container = createCanvasContainer()\n\nfunction createCharacterSheet(imageFile) {\n  var img = document.createElement('img')\n  img.src = imageFile\n  img.className = 'character-sheet'\n  img.onload = function() {\n    splashScreen()\n  }\n  document.body.appendChild(img)\n  return img\n}\n\nvar charSheet = createCharacterSheet('Codepage-850_alpha.png')\n\nvar splashRenderer = new Renderer('splash', 0, 0, canvasWidthChars, canvasHeightChars).init(container, charSheet)\n\nvar statsRenderer = new Renderer('stats', 0,\n  mapWidth, statsWidth, statsHeight).init(container, charSheet)\n\nvar logRenderer = new Renderer('log', mapHeight, 0, logWidth, logHeight).init(container, charSheet)\n\nvar colorRenderer = new Renderer('color', 0, 0, mapWidth, mapHeight).init(container, charSheet)\nvar visibleRenderer = new Renderer('visible', 0, 0, mapWidth, mapHeight).init(container, charSheet)\nvar levelRenderer = new Renderer('level', 0, 0, mapWidth, mapHeight).init(container, charSheet)\nvar objectRenderer = new Renderer('objects', 0, 0, mapWidth, mapHeight).init(container, charSheet)\nvar seenRenderer = new Renderer('seen', 0, 0, mapWidth, mapHeight).init(container, charSheet)\nvar debugRenderer = new Renderer('debug', 0, 0, mapWidth, mapHeight).init(container, charSheet)\n\nvar hofRenderer = new Renderer('hof', 0, 0, canvasWidthChars, canvasHeightChars).init(container, charSheet)\n\nvar movementKeys = 'uiojklm,.'\nvar keyDisplacement = {\n  u: { dx: -1, dy: -1 },\n  i: { dx: 0, dy: -1 },\n  o: { dx: 1, dy: -1 },\n  j: { dx: -1, dy: 0 },\n  k: { dx: 0, dy: 0 },\n  l: { dx: 1, dy: 0 },\n  m: { dx: -1, dy: 1 },\n  ',': { dx: 0, dy: 1 },\n  '.': { dx: 1, dy: 1 }\n}\nvar keyToDir = {\n  u: 7,\n  i: 0,\n  o: 1,\n  j: 6,\n  k: NaN,\n  l: 2,\n  m: 5,\n  ',': 4,\n  '.': 3\n}\n\nfunction Game(gameOptions) {\n  this.resetRenderFlags = function resetRenderFlags() {\n    this.shouldRenderStats = true\n    this.shouldRenderLog = true\n    this.shouldRenderLevel = true\n    this.shouldRenderObjects = true\n    this.shouldRenderSeen = true\n    this.shouldRenderVisible = true\n  }\n  this.resetRenderFlags()\n\n  this.isFinished = false\n  this.levels = []\n  this.currentLevel = 0\n\n  this.addNewLevel = function addNewLevel() {\n    var newLevel = new Level(this.levels.length, { down: true, up: this.levels.length > 0 })\n    this.levels.push(newLevel)\n    return newLevel\n  }\n  this.isFirstLevel = function isFirstLevel() {\n    return this.currentLevel == 0\n  }\n  this.isLatestLevel = function isLatestLevel() {\n    return this.currentLevel == this.levels.length - 1\n  }\n\n  var logger = Logger.getInstance()\n  logger.appendToLine(`Welcome, ${gameOptions.playerName}!`)\n  logger.finishLine()\n\n  this.addNewLevel()\n\n  seenRenderer.fillWithChar(' ')\n\n  this.player = new Player('@', 'green', gameOptions.playerName)\n  var playerPosition = this.levels[this.currentLevel].getRandomUnoccupiedTile()\n  this.player.setPosition(playerPosition)\n  this.levels[this.currentLevel].placePlayer(this.player)\n\n  this.getStatsLines = function getStatsLines() {\n    return [\n      this.player.name,\n      'D  ' + String(this.currentLevel).padStart(5, ' '),\n      'HP ' + String(this.player.hp).padStart(5, ' '),\n      '$  ' + String(this.player.score).padStart(5, ' ')\n    ]\n  }\n\n  this.updatePlayerEnvironment = function updatePlayerEnvironment(dir) {\n    this.playerEnvironment = this.levels[this.currentLevel].tileMap.aroundDir(this.player, dir).join('')\n  }\n  this.updatePlayerEnvironment(NaN)\n\n  this.engageAutoPilot = function engageAutoPilot(key) {\n    this.isOnAutoPilot = true\n    this.autoPilotEvent = { key }\n    this.autoPilotEnvironment = this.playerEnvironment\n  }\n\n  this.disengageAutoPilot = function disengageAutoPilot() {\n    this.isOnAutoPilot = false\n    this.autoPilotEvent = undefined\n    this.autoPilotEnvironment = undefined\n  }\n  this.disengageAutoPilot()\n\n  this.updateState = function updateState(event) {\n    var dx, dy\n\n    var key = event.key\n\n    var level = this.levels[this.currentLevel]\n\n    var playerTurnDone = false\n\n    var logger = Logger.getInstance()\n    this.shouldRenderLog = true\n\n    if (this.player.hp <= 0) {\n      this.shouldRenderLog = false\n      return\n    }\n\n    if (movementKeys.includes(key)) {\n      ({ dx, dy } = keyDisplacement[key])\n      var dir = keyToDir[key]\n      if (this.player.attacking) {\n        var monster = level.getMonsterAt(this.player.x + dx, this.player.y + dy)\n        if (monster) {\n          var success = this.player.attack(monster)\n          if (success) {\n            logger.appendToLine(`You hit the ${monster.name}.`)\n          } else {\n            logger.appendToLine(`You miss the ${monster.name}.`)\n          }\n          if (monster.hp <= 0) {\n            logger.appendToLine(`The ${monster.name} is killed.`)\n            this.player.score += monster.pointValue\n            this.shouldRenderStats = true\n            level.unoccupy(monster)\n          }\n        }\n        this.player.attacking = false\n        this.shouldRenderObjects = true\n        playerTurnDone = true\n      } else if (this.player.startedAutoWalk) {\n        console.log('auto-walk')\n        this.updatePlayerEnvironment(dir)\n        this.engageAutoPilot(key)\n        this.player.startedAutoWalk = false\n      } else {\n        if (dx == 0 && dy == 0) {\n          playerTurnDone = true\n          this.disengageAutoPilot()\n        } else if (!level.isOccupied[this.player.y + dy][this.player.x + dx]) {\n          level.unoccupy(this.player)\n          this.player.x += dx\n          this.player.y += dy\n          level.placePlayer(this.player)\n          this.shouldRenderSeen = true\n          this.shouldRenderVisible = true\n          playerTurnDone = true\n          this.updatePlayerEnvironment(dir)\n          if (this.isOnAutoPilot) {\n            // check if surroundings of player change\n            if (this.playerEnvironment != this.autoPilotEnvironment) {\n              this.disengageAutoPilot()\n            }\n          }\n        } else {\n          // Moving against occupied space, turn not done\n          this.disengageAutoPilot()\n        }\n        this.shouldRenderObjects = true\n      }\n    } else {\n      switch (key) {\n        case 'a':\n          this.player.attacking = true\n          break\n        case 'g':\n          this.player.startedAutoWalk = true\n          break\n        case 's':\n          if (level.isDownStaircaseAt(this.player)) {\n            var newLevel\n            if (this.isLatestLevel()) {\n              newLevel = this.addNewLevel()\n            } else {\n              newLevel = this.levels[this.currentLevel + 1]\n            }\n            logger.appendToLine('You descend the staircase.')\n            this.currentLevel += 1\n            this.resetRenderFlags()\n            this.player.setPosition(newLevel.getUpStaircasePosition())\n            newLevel.placePlayer(this.player)\n          } else if (level.isUpStaircaseAt(this.player)) {\n            var newLevel = this.levels[this.currentLevel - 1]\n            logger.appendToLine('You ascend the staircase.')\n            this.currentLevel -= 1\n            this.resetRenderFlags()\n            this.player.setPosition(newLevel.getDownStaircasePosition())\n            newLevel.placePlayer(this.player)\n          }\n          break\n        default:\n          console.log('unknown command: ' + key)\n      }\n    }\n\n    if (playerTurnDone) {\n      for (var iMonster = 0; iMonster < level.monsters.length; iMonster++) {\n        var monster = level.monsters[iMonster]\n        if (monster.hp > 0) {\n          if (!monster.seen && level.isVisibleMask[monster.y][monster.x]) {\n            monster.seen = true\n          } else if (monster.seen && !level.isVisibleMask[monster.y][monster.x]) {\n            monster.seen = false\n          }\n          if (monster.seen) {\n            this.disengageAutoPilot()\n          }\n          monster.rollAggravation()\n          if (monster.aggressive && monster.seen) {\n            if (monster.isAdjacentTo(this.player)) {\n              dx = 0\n              dy = 0\n              var success = monster.attack(this.player)\n              if (success) {\n                logger.appendToLine(`The ${monster.name} hits you.`)\n                this.shouldRenderStats = true\n              } else {\n                logger.appendToLine(`The ${monster.name} misses you.`)\n              }\n              if (this.player.hp <= 0) {\n                this.player.killedBy = `a ${monster.name}`\n                logger.appendToLine('You die. Press Enter to continue...')\n                this.isFinished = true\n                break\n              }\n            } else {\n              var vectors = monster.getApproachVectorsTo(this.player)\n              var vectorFound = false\n              for (var v of vectors) {\n                if (!level.isOccupied[monster.y + v.dy][monster.x + v.dx]) {\n                  dx = v.dx\n                  dy = v.dy\n                  vectorFound = true\n                  break\n                }\n              }\n              if (!vectorFound) {\n                dx = 0\n                dy = 0\n              }\n            }\n          } else {\n            var dirInd = Math.floor(9 * Math.random())\n            var dir = movementKeys[dirInd]\n            ;({ dx, dy } = keyDisplacement[dir])\n            if (level.isOccupied[monster.y + dy][monster.x + dx]) {\n              dx = 0\n              dy = 0\n            }\n          }\n          level.unoccupy(monster)\n          monster.x += dx\n          monster.y += dy\n          level.occupy(monster)\n        }\n      }\n    }\n    logger.finishLine()\n  }\n\n  this.render = function render() {\n    if (this.shouldRenderStats) {\n      this.renderStats()\n      this.shouldRenderStats = false\n    }\n    if (this.shouldRenderLog) {\n      this.renderLog()\n      this.shouldRenderLog = false\n    }\n    if (this.shouldRenderLevel) {\n      this.renderLevel()\n      this.shouldRenderLevel = false\n    }\n    if (this.shouldRenderObjects) {\n      this.renderObjects()\n      this.shouldRenderObjects = false\n    }\n    if (this.shouldRenderSeen) {\n      this.renderSeen()\n      this.shouldRenderSeen = false\n    }\n    if (this.shouldRenderVisible) {\n      this.renderVisible()\n      this.shouldRenderVisible = false\n    }\n  }\n\n  this.renderStats = function renderStats() {\n    statsRenderer.clear()\n    var statsLines = this.getStatsLines()\n    statsRenderer.drawText(''.padEnd(statsWidth, ' '), defaultTextColor, 0, 0)\n    var iLine = 1\n    for (var line of statsLines) {\n      statsRenderer.drawText(line.padEnd(statsWidth, ' '), defaultTextColor, iLine, 0)\n      iLine += 1\n    }\n    while (iLine < statsHeight) {\n      statsRenderer.drawText(''.padEnd(statsWidth, ' '), defaultTextColor, iLine, 0)\n      iLine += 1\n    }\n  }\n\n  this.renderLog = function renderLog() {\n    logRenderer.clear()\n    var logger = Logger.getInstance()\n    var logLines = logger.getLogLines()\n    var iLine = 1\n    for (var line of logLines) {\n      logRenderer.drawText(line, defaultTextColor, -iLine, 0)\n      iLine += 1\n    }\n  }\n\n  this.renderLevel = function renderLevel() {\n    levelRenderer.clear()\n    var level = this.levels[this.currentLevel]\n    for (var i = 0; i < mapHeight; i++) {\n      for (var j = 0; j < mapWidth; j++) {\n        var tile = level.tileMap.data[i][j]\n        colorRenderer.drawTile(level.colorMap[tile], i, j)\n        levelRenderer.drawChar(tile, i, j)\n      }\n    }\n  }\n\n  this.renderObjects = function renderObjects() {\n    objectRenderer.clear()\n    objectRenderer.drawColoredChar(this.player.char, this.player.color, this.player.y, this.player.x)\n\n    var level = this.levels[this.currentLevel]\n    for (var iMonster = 0; iMonster < level.monsters.length; iMonster++) {\n      var monster = level.monsters[iMonster]\n      if (monster.hp > 0 && level.isVisibleMask[monster.y][monster.x]) {\n        objectRenderer.drawColoredChar(monster.char, monster.color, monster.y, monster.x)\n      }\n    }\n  }\n\n  this.renderSeen = function renderSeen() {\n    var level = this.levels[this.currentLevel]\n    for (var i = 0; i < mapHeight; i++) {\n      for (var j = 0; j < mapWidth; j++) {\n        if (level.seenMask[i][j]) {\n          seenRenderer.clearTile(i, j)\n        } else {\n          seenRenderer.drawChar(' ', i, j)\n        }\n      }\n    }\n  }\n\n  this.renderVisible = function renderVisible() {\n    var level = this.levels[this.currentLevel]\n    for (var i = 0; i < mapHeight; i++) {\n      for (var j = 0; j < mapWidth; j++) {\n        if (level.isVisibleMask[i][j]) {\n          visibleRenderer.clearTile(i, j)\n        } else if (level.becameNotVisible(i, j)) {\n          visibleRenderer.drawTile('rgba(0, 0, 0, 0.2)', i, j)\n        }\n      }\n    }\n  }\n\n  this.clear = function clear() {\n    var logger = Logger.getInstance()\n    logger.clearBuffer()\n\n    statsRenderer.clear()\n    logRenderer.clear()\n    colorRenderer.clear()\n    visibleRenderer.clear()\n    levelRenderer.clear()\n    objectRenderer.clear()\n    seenRenderer.clear()\n    debugRenderer.clear()\n  }\n}\n\nvar alphabet = 'abcdefghijklmnopqrstuvxyz'\n\nfunction splashScreen() {\n  var shouldRenderSplash = true\n  var shouldRenderPlayerName = true\n  var playerName = ''\n\n  var splashAnimationHandle\n\n  function renderSplashScreen() {\n    if (shouldRenderSplash) {\n      splashRenderer.fillWithChar(' ')\n      splashRenderer.drawText('a roguelike game', defaultTextColor, 10, 5)\n      splashRenderer.drawText('please enter your name: ', defaultTextColor, 12, 5)\n      shouldRenderSplash = false\n    }\n\n    if (shouldRenderPlayerName) {\n      splashRenderer.drawText(`${playerName}_`.padEnd(16, ' '), defaultTextColor, 12, 29)\n      shouldRenderPlayerName = false\n    }\n\n    splashAnimationHandle = window.requestAnimationFrame(renderSplashScreen)\n  }\n\n  function handleNameInput(e) {\n    if (alphabet.includes(e.key) && playerName.length < 15) {\n      playerName += e.key\n      shouldRenderPlayerName = true\n    }\n    if (e.key == 'Backspace') {\n      playerName = playerName.slice(0, playerName.length - 1)\n      shouldRenderPlayerName = true\n    }\n  }\n\n  function handleSubmitName(e) {\n    if (e.key == 'Enter' && playerName.length > 0) {\n      window.removeEventListener('keydown', handleNameInput)\n      window.removeEventListener('keyup', handleSubmitName)\n      window.cancelAnimationFrame(splashAnimationHandle)\n      splashRenderer.clear()\n      startGame({\n        playerName\n      })\n    }\n  }\n\n  window.addEventListener('keydown', handleNameInput)\n  window.addEventListener('keyup', handleSubmitName)\n\n  splashAnimationHandle = window.requestAnimationFrame(renderSplashScreen)\n}\n\nfunction startGame(gameOptions) {\n  var gameAnimationHandle\n\n  var game = new Game(gameOptions)\n\n  function gameLoop() {\n    if (game.isOnAutoPilot) {\n      game.updateState(game.autoPilotEvent)\n      if (!game.isOnAutoPilot) {\n        window.addEventListener('keyup', handleGameInput)\n      }\n    }\n    game.render()\n    gameAnimationHandle = window.requestAnimationFrame(gameLoop)\n  }\n\n  function handleGameInput(e) {\n    game.updateState(e)\n    if (game.isOnAutoPilot) {\n      window.removeEventListener('keyup', handleGameInput)\n    }\n    if (e.key == 'Enter' && game.isFinished) {\n      window.removeEventListener('keyup', handleGameInput)\n      game.clear()\n      window.cancelAnimationFrame(gameAnimationHandle)\n\n      hallOfFame({\n        newEntry: {\n          player: game.player.name,\n          score: game.player.score,\n          version: GAME_VERSION,\n          date: new Date().toISOString().slice(0, 10),\n          dungeonLevel: game.currentLevel,\n          causeOfDeath: game.player.killedBy,\n          isNewEntry: true\n        }\n      })\n    }\n  }\n\n  window.addEventListener('keyup', handleGameInput)\n\n  gameAnimationHandle = window.requestAnimationFrame(gameLoop)\n}\n\nfunction hallOfFame(hofOptions) {\n  var shouldRenderHof = true\n  var hofAnimationHandle\n\n  var numHofEntries = 8\n  var onlineRanking = -1\n  var onlineHof = []\n\n  var hofUrl = 'https://roguelike.wildfirecanvas.com/roguelike/hof'\n  fetch(hofUrl, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify(hofOptions.newEntry)\n  }).then(res => res.json()).then(res => {\n    onlineHof = res.hof\n    onlineRanking = res.ranking\n    shouldRenderHof = true\n  }).catch(err => {\n    console.log('error posting to HOF')\n    console.error(err)\n  })\n\n  function renderHof() {\n    if (shouldRenderHof) {\n      hofRenderer.fillWithChar(' ')\n      hofRenderer.drawText(`roguelike game version ${GAME_VERSION} high scores`, defaultTextColor, 1, 1)\n\n      onlineHof\n        .slice(0, numHofEntries)\n        .forEach((entry, ind) => {\n          hofRenderer.drawText(\n            `${String(ind + 1).padStart(3, ' ')} ${entry.Player.padEnd(15, ' ')} ${String(entry.Score).padStart(5, ' ')} ${entry.Version}`,\n            entry.isNewEntry ? '#bb5' : defaultTextColor,\n            2 * ind + 4,\n            1\n          )\n          hofRenderer.drawText(\n            `killed by ${entry.CauseOfDeath} on level ${entry.DungeonLevel} on ${entry.Date}`,\n            entry.isNewEntry ? '#773' : '#666',\n            2 * ind + 5,\n            5\n          )\n      })\n\n      var congratsText = ''\n      if (onlineRanking > -1 && onlineRanking <= numHofEntries) {\n        congratsText += 'congrats on making it to the top ' + numHofEntries\n      } else {\n        congratsText += `your online ranking with score ${hofOptions.newEntry.score} is ${onlineRanking}`\n      }\n      hofRenderer.drawText(congratsText, defaultTextColor, 22, 1)\n      hofRenderer.drawText('press enter to start a new game', defaultTextColor, 23, 1)\n\n      shouldRenderHof = false\n    }\n\n    hofAnimationHandle = window.requestAnimationFrame(renderHof)\n  }\n\n  function handleEnterKey(e) {\n    if (e.key == 'Enter') {\n      window.cancelAnimationFrame(hofAnimationHandle)\n      window.removeEventListener('keyup', handleEnterKey)\n      hofRenderer.clear()\n      splashScreen()\n    }\n  }\n\n  window.addEventListener('keyup', handleEnterKey)\n\n  hofAnimationHandle = window.requestAnimationFrame(renderHof)\n}\n"],"names":[],"sourceRoot":""}